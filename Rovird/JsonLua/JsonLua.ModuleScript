{
 "className": "ModuleScript",
 "name": "JsonLua",
 "referent": "RBX25BF4804AB964332BCD46D64AD669EDE",
 "properties": {
  "AttributesSerialize": {
   "_propertyType": "BinaryString",
   "values": {}
  },
  "Tags": {
   "_propertyType": "BinaryString",
   "values": {}
  },
  "LinkedSource": {
   "_propertyType": "Content",
   "values": {
    "null": [
     ""
    ]
   }
  },
  "Name": {
   "_propertyType": "string",
   "values": {
    "_": "JsonLua"
   }
  },
  "ScriptGuid": {
   "_propertyType": "string",
   "values": {
    "_": "{FF2942E7-2D3A-4B14-B47B-C90473EF4187}"
   }
  },
  "Source": {
   "_propertyType": "ProtectedString",
   "values": {
    "_": "local json = { _version = \"0.1.2\" }\n\n-------------------------------------------------------------------------------\n-- Encode\n-------------------------------------------------------------------------------\n\nlocal encode\n\nlocal escape_char_map = {\n\t[ \"\\\\\" ] = \"\\\\\\\\\",\n\t[ \"\\\"\" ] = \"\\\\\\\"\",\n\t[ \"\\b\" ] = \"\\\\b\",\n\t[ \"\\f\" ] = \"\\\\f\",\n\t[ \"\\n\" ] = \"\\\\n\",\n\t[ \"\\r\" ] = \"\\\\r\",\n\t[ \"\\t\" ] = \"\\\\t\",\n}\n\nlocal escape_char_map_inv = { [ \"\\\\/\" ] = \"/\" }\nfor k, v in pairs(escape_char_map) do\n\tescape_char_map_inv[v] = k\nend\n\n\nlocal function escape_char(c)\n\treturn escape_char_map[c] or string.format(\"\\\\u%04x\", c:byte())\nend\n\n\nlocal function encode_nil(val)\n\treturn \"null\"\nend\n\n\nlocal function encode_table(val, stack)\n\tlocal res = {}\n\tstack = stack or {}\n\n\t-- Circular reference?\n\tif stack[val] then error(\"circular reference\") end\n\n\tstack[val] = true\n\n\tif rawget(val, 1) ~= nil or next(val) == nil then\n\t\t-- Treat as array -- check keys are valid and it is not sparse\n\t\tlocal n = 0\n\t\tfor k in pairs(val) do\n\t\t\tif type(k) ~= \"number\" then\n\t\t\t\terror(\"invalid table: mixed or invalid key types\")\n\t\t\tend\n\t\t\tn = n + 1\n\t\tend\n\t\tif n ~= #val then\n\t\t\terror(\"invalid table: sparse array\")\n\t\tend\n\t\t-- Encode\n\t\tfor i, v in ipairs(val) do\n\t\t\ttable.insert(res, encode(v, stack))\n\t\tend\n\t\tstack[val] = nil\n\t\treturn \"[\" .. table.concat(res, \",\") .. \"]\"\n\n\telse\n\t\t-- Treat as an object\n\t\tfor k, v in pairs(val) do\n\t\t\tif type(k) ~= \"string\" then\n\t\t\t\terror(\"invalid table: mixed or invalid key types\")\n\t\t\tend\n\t\t\ttable.insert(res, encode(k, stack) .. \":\" .. encode(v, stack))\n\t\tend\n\t\tstack[val] = nil\n\t\treturn \"{\" .. table.concat(res, \",\") .. \"}\"\n\tend\nend\n\n\nlocal function encode_string(val)\n\treturn '\"' .. val:gsub('[%z\\1-\\31\\\\\"]', escape_char) .. '\"'\nend\n\n\nlocal function encode_number(val)\n\t-- Check for NaN, -inf and inf\n\tif val ~= val or val <= -math.huge or val >= math.huge then\n\t\terror(\"unexpected number value '\" .. tostring(val) .. \"'\")\n\tend\n\treturn string.format(\"%.14g\", val)\nend\n\n\nlocal type_func_map = {\n\t[ \"nil\"     ] = encode_nil,\n\t[ \"table\"   ] = encode_table,\n\t[ \"string\"  ] = encode_string,\n\t[ \"number\"  ] = encode_number,\n\t[ \"boolean\" ] = tostring,\n}\n\n\nencode = function(val, stack)\n\tlocal t = type(val)\n\tlocal f = type_func_map[t]\n\tif f then\n\t\treturn f(val, stack)\n\tend\n\terror(\"unexpected type '\" .. t .. \"'\")\nend\n\n\nfunction json.encode(val)\n\treturn ( encode(val) )\nend\n\n\n-------------------------------------------------------------------------------\n-- Decode\n-------------------------------------------------------------------------------\n\nlocal parse\n\nlocal function create_set(...)\n\tlocal res = {}\n\tfor i = 1, select(\"#\", ...) do\n\t\tres[ select(i, ...) ] = true\n\tend\n\treturn res\nend\n\nlocal space_chars   = create_set(\" \", \"\\t\", \"\\r\", \"\\n\")\nlocal delim_chars   = create_set(\" \", \"\\t\", \"\\r\", \"\\n\", \"]\", \"}\", \",\")\nlocal escape_chars  = create_set(\"\\\\\", \"/\", '\"', \"b\", \"f\", \"n\", \"r\", \"t\", \"u\")\nlocal literals      = create_set(\"true\", \"false\", \"null\")\n\nlocal literal_map = {\n\t[ \"true\"  ] = true,\n\t[ \"false\" ] = false,\n\t[ \"null\"  ] = nil,\n}\n\n\nlocal function next_char(str, idx, set, negate)\n\tfor i = idx, #str do\n\t\tif set[str:sub(i, i)] ~= negate then\n\t\t\treturn i\n\t\tend\n\tend\n\treturn #str + 1\nend\n\n\nlocal function decode_error(str, idx, msg)\n\tlocal line_count = 1\n\tlocal col_count = 1\n\tfor i = 1, idx - 1 do\n\t\tcol_count = col_count + 1\n\t\tif str:sub(i, i) == \"\\n\" then\n\t\t\tline_count = line_count + 1\n\t\t\tcol_count = 1\n\t\tend\n\tend\n\terror( string.format(\"%s at line %d col %d\", msg, line_count, col_count) )\nend\n\n\nlocal function codepoint_to_utf8(n)\n\t-- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa\n\tlocal f = math.floor\n\tif n <= 0x7f then\n\t\treturn string.char(n)\n\telseif n <= 0x7ff then\n\t\treturn string.char(f(n / 64) + 192, n % 64 + 128)\n\telseif n <= 0xffff then\n\t\treturn string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)\n\telseif n <= 0x10ffff then\n\t\treturn string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,\n\t\t\tf(n % 4096 / 64) + 128, n % 64 + 128)\n\tend\n\terror( string.format(\"invalid unicode codepoint '%x'\", n) )\nend\n\n\nlocal function parse_unicode_escape(s)\n\tlocal n1 = tonumber( s:sub(3, 6),  16 )\n\tlocal n2 = tonumber( s:sub(9, 12), 16 )\n\t-- Surrogate pair?\n\tif n2 then\n\t\treturn codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)\n\telse\n\t\treturn codepoint_to_utf8(n1)\n\tend\nend\n\n\nlocal function parse_string(str, i)\n\tlocal has_unicode_escape = false\n\tlocal has_surrogate_escape = false\n\tlocal has_escape = false\n\tlocal last\n\tfor j = i + 1, #str do\n\t\tlocal x = str:byte(j)\n\n\t\tif x < 32 then\n\t\t\tdecode_error(str, j, \"control character in string\")\n\t\tend\n\n\t\tif last == 92 then -- \"\\\\\" (escape char)\n\t\t\tif x == 117 then -- \"u\" (unicode escape sequence)\n\t\t\t\tlocal hex = str:sub(j + 1, j + 5)\n\t\t\t\tif not hex:find(\"%x%x%x%x\") then\n\t\t\t\t\tdecode_error(str, j, \"invalid unicode escape in string\")\n\t\t\t\tend\n\t\t\t\tif hex:find(\"^[dD][89aAbB]\") then\n\t\t\t\t\thas_surrogate_escape = true\n\t\t\t\telse\n\t\t\t\t\thas_unicode_escape = true\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tlocal c = string.char(x)\n\t\t\t\tif not escape_chars[c] then\n\t\t\t\t\tdecode_error(str, j, \"invalid escape char '\" .. c .. \"' in string\")\n\t\t\t\tend\n\t\t\t\thas_escape = true\n\t\t\tend\n\t\t\tlast = nil\n\n\t\telseif x == 34 then -- '\"' (end of string)\n\t\t\tlocal s = str:sub(i + 1, j - 1)\n\t\t\tif has_surrogate_escape then\n\t\t\t\ts = s:gsub(\"\\\\u[dD][89aAbB]..\\\\u....\", parse_unicode_escape)\n\t\t\tend\n\t\t\tif has_unicode_escape then\n\t\t\t\ts = s:gsub(\"\\\\u....\", parse_unicode_escape)\n\t\t\tend\n\t\t\tif has_escape then\n\t\t\t\ts = s:gsub(\"\\\\.\", escape_char_map_inv)\n\t\t\tend\n\t\t\treturn s, j + 1\n\n\t\telse\n\t\t\tlast = x\n\t\tend\n\tend\n\tdecode_error(str, i, \"expected closing quote for string\")\nend\n\n\nlocal function parse_number(str, i)\n\tlocal x = next_char(str, i, delim_chars)\n\tlocal s = str:sub(i, x - 1)\n\tlocal n = tonumber(s)\n\tif not n then\n\t\tdecode_error(str, i, \"invalid number '\" .. s .. \"'\")\n\tend\n\treturn n, x\nend\n\n\nlocal function parse_literal(str, i)\n\tlocal x = next_char(str, i, delim_chars)\n\tlocal word = str:sub(i, x - 1)\n\tif not literals[word] then\n\t\tdecode_error(str, i, \"invalid literal '\" .. word .. \"'\")\n\tend\n\treturn literal_map[word], x\nend\n\n\nlocal function parse_array(str, i)\n\tlocal res = {}\n\tlocal n = 1\n\ti = i + 1\n\twhile 1 do\n\t\tlocal x\n\t\ti = next_char(str, i, space_chars, true)\n\t\t-- Empty / end of array?\n\t\tif str:sub(i, i) == \"]\" then\n\t\t\ti = i + 1\n\t\t\tbreak\n\t\tend\n\t\t-- Read token\n\t\tx, i = parse(str, i)\n\t\tres[n] = x\n\t\tn = n + 1\n\t\t-- Next token\n\t\ti = next_char(str, i, space_chars, true)\n\t\tlocal chr = str:sub(i, i)\n\t\ti = i + 1\n\t\tif chr == \"]\" then break end\n\t\tif chr ~= \",\" then decode_error(str, i, \"expected ']' or ','\") end\n\tend\n\treturn res, i\nend\n\n\nlocal function parse_object(str, i)\n\tlocal res = {}\n\ti = i + 1\n\twhile 1 do\n\t\tlocal key, val\n\t\ti = next_char(str, i, space_chars, true)\n\t\t-- Empty / end of object?\n\t\tif str:sub(i, i) == \"}\" then\n\t\t\ti = i + 1\n\t\t\tbreak\n\t\tend\n\t\t-- Read key\n\t\tif str:sub(i, i) ~= '\"' then\n\t\t\tdecode_error(str, i, \"expected string for key\")\n\t\tend\n\t\tkey, i = parse(str, i)\n\t\t-- Read ':' delimiter\n\t\ti = next_char(str, i, space_chars, true)\n\t\tif str:sub(i, i) ~= \":\" then\n\t\t\tdecode_error(str, i, \"expected ':' after key\")\n\t\tend\n\t\ti = next_char(str, i + 1, space_chars, true)\n\t\t-- Read value\n\t\tval, i = parse(str, i)\n\t\t-- Set\n\t\tres[key] = val\n\t\t-- Next token\n\t\ti = next_char(str, i, space_chars, true)\n\t\tlocal chr = str:sub(i, i)\n\t\ti = i + 1\n\t\tif chr == \"}\" then break end\n\t\tif chr ~= \",\" then decode_error(str, i, \"expected '}' or ','\") end\n\tend\n\treturn res, i\nend\n\n\nlocal char_func_map = {\n\t[ '\"' ] = parse_string,\n\t[ \"0\" ] = parse_number,\n\t[ \"1\" ] = parse_number,\n\t[ \"2\" ] = parse_number,\n\t[ \"3\" ] = parse_number,\n\t[ \"4\" ] = parse_number,\n\t[ \"5\" ] = parse_number,\n\t[ \"6\" ] = parse_number,\n\t[ \"7\" ] = parse_number,\n\t[ \"8\" ] = parse_number,\n\t[ \"9\" ] = parse_number,\n\t[ \"-\" ] = parse_number,\n\t[ \"t\" ] = parse_literal,\n\t[ \"f\" ] = parse_literal,\n\t[ \"n\" ] = parse_literal,\n\t[ \"[\" ] = parse_array,\n\t[ \"{\" ] = parse_object,\n}\n\n\nparse = function(str, idx)\n\tlocal chr = str:sub(idx, idx)\n\tlocal f = char_func_map[chr]\n\tif f then\n\t\treturn f(str, idx)\n\tend\n\tdecode_error(str, idx, \"unexpected character '\" .. chr .. \"'\")\nend\n\n\nfunction json.decode(str)\n\tif type(str) ~= \"string\" then\n\t\terror(\"expected argument of type string, got \" .. type(str))\n\tend\n\tlocal res, idx = parse(str, next_char(str, 1, space_chars, true))\n\tidx = next_char(str, idx, space_chars, true)\n\tif idx <= #str then\n\t\tdecode_error(str, idx, \"trailing garbage\")\n\tend\n\treturn res\nend\n\n\nreturn json"
   }
  },
  "SourceAssetId": {
   "_propertyType": "int64",
   "values": {
    "_": "-1"
   }
  }
 },
 "_exportInfo": "Exported with rbx-export v1.1.0. Contains all properties of this instance."
}